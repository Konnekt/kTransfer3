// $Revision: 1.9 $
/*
  Copyright (c) 2005, Thomas Hansen
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice,
		this list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice, 
		this list of conditions and the following disclaimer in the documentation 
		and/or other materials provided with the distribution.
	  * Neither the name of the SmartWin++ nor the names of its contributors 
		may be used to endorse or promote products derived from this software 
		without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
Parses a subset of HTML into SmartWin Widgets:
( The routines in html_get.h parse the html generated by html_put.h. )

bool html_get_begin( iostream &itsIo )
bool html_get( iostream &io, WidgetDataGrid * grid )
bool html_get( iostream &io, WidgetTreeView *tree )

It uses HTML 3.2, as defined in "HTML 3.2 Reference Specification" by W3C

These serialization routines are not put in each Widget's class so that it
is easy to produce a html file containing multiple Widgets.

*/

#ifndef html_get_64683
#define html_get_64683

#include "SmartWin.h"
using namespace SmartWin;
using namespace std;

//-------------------------------------------------------------------------

class html_get
{
private:
	iostream & itsIo;

public:
	// Constructor parses until it finds a <form> tag.
	//
	html_get( iostream & io, bool & ok )
		: itsIo( io )
	{
		ok = false;

		string tag;
		do
		{
			itsIo >> tag;
			if ( 0 == tag.size() ) return;
		} while ( "<form>" != tag );

		ok = true;
	}

	//-------------------------------------------------------------------------

	// Parses the string inbetween <p> and </p>.
	//
	bool get_string( SmartUtil::tstring & text )
	{
		string tag;
		itsIo >> tag;
		if ( "<p>" != tag ) return false;

		return( parse_until( "</p>", text ) );
	}

	//-------------------------------------------------------------------------

	// get( WidgetTextBox * inTextBox )
	//
	template< class Parent, class MessageMapPolicy >
	bool get( SmartWin::WidgetTextBox< Parent, MessageMapPolicy > * inTextBox )
	{
		SmartUtil::tstring text;
		bool ok = get_string( text );
		if ( ok ) inTextBox->setText( text );
		return ok;
	}

	//-------------------------------------------------------------------------

	// get( WidgetRichTextBox * inWidgetRichTextBox )
	//
	template< class Parent, class MessageMapPolicy >
	bool get( SmartWin::WidgetRichTextBox< Parent, MessageMapPolicy, sw::RichTextBox< Parent, MessageMapPolicy > > * inWidgetRichTextBox )
	{
		SmartUtil::tstring text;
		bool ok = get_string( text );
		if ( ok ) inWidgetRichTextBox->setText( text );
		return ok;
	}

	//-------------------------------------------------------------------------

	// Set value to 12 from:
	// <input type="text" value="12" >
	//
	bool get_val_of_text( int & value )
	{
		string tag, checkname;
		itsIo >> tag;
		if ( "<input" != tag ) return false;

		itsIo >> tag;
		if ( "type=text" != tag ) return false;

		itsIo >> tag; // value="43"
		if ( ! parse_quoted_numeric_value( tag, value ) )
			return false;

		itsIo >> tag; if ( ">" != tag ) return false;

		return true;
	}

	// get( WidgetSlider * inSlider )
	// <input type="text" value="12" >
	//
	template< class Parent, class MessageMapPolicy >
	bool get( SmartWin::WidgetSlider< Parent, MessageMapPolicy > * inSlider )
	{
		int value;
		bool ok = get_val_of_text( value );
		if ( ok ) inSlider->setPosition( value );
		return ok;
	}

	//-------------------------------------------------------------------------

	// get( WidgetSpinner * inSpinner )
	// <input type=text value="100" >
	//
	template< class Parent, class MessageMapPolicy >
	bool get( SmartWin::WidgetSpinner< Parent, MessageMapPolicy > * inSpinner )
	{
		int value;
		bool ok = get_val_of_text( value );
		if ( ok ) inSpinner->setValue( value );
		return ok;
	}

	// get( WidgetComboBox * wcb )
	//
	// <select>
	// <option value="www.google.com" > www.google.com </option>
	// <option value="www.apple.com" selected > www.apple.com </option>
	// <option value="www.ibm.com" > www.ibm.com </option>
	// <option value="www.sun.com" > www.sun.com </option>
	// <option value="192.168.1.100" > 192.168.1.100 </option>
	// <option value="www.dell.com" > www.dell.com </option>
	// </select>
	//
	template< class Parent, class MessageMapPolicy >
	bool get( SmartWin::WidgetComboBox< Parent, MessageMapPolicy > * inComboBox )
	{
		string tag, value;
		itsIo >> tag;
		if ( "<select>" != tag ) return false;

		inComboBox->removeAllItems();
		int dex = 0;
		bool selected = false;
		itsIo >> tag;
		while ( "</select>" != tag )
		{
			if ( "<option" != tag ) return false;

			// Skip until >
			itsIo >> value >> tag;
			if ( ">" != tag )
			{
				if ( "selected" == tag )
				{
					selected = true; // Remember this index was selected.
					itsIo >> tag;
					if ( ">" != tag ) return false;
				}
				else
					return false; // wanted ">" or "selected"
			}

			if ( ! parse_until( "</option>", value ) )
				return false;

			// Add the data string to the ComboBox
			inComboBox->addValue( value );
			if ( selected )
			{
				inComboBox->setSelectedIndex( dex );
				selected = false;
			}
			dex++;
			itsIo >> tag;
		};

		return true;
	}

	//-------------------------------------------------------------------------

	// get( WidgetCheckBox * inCheckBox )
	//
	//      <input type=checkbox checked value= "HTTP Get" > HTTP Get </input>
	//
	template< class Parent, class MessageMapPolicy >
	bool get( SmartWin::WidgetCheckBox< Parent, MessageMapPolicy > * inCheckBox )
	{
		string tag, checkname;
		itsIo >> tag;
		if ( "<input" != tag ) return false;

		itsIo >> tag;
		if ( "type=checkbox" != tag ) return false;

		itsIo >> tag;
		if ( "value=" == tag )
		{
			inCheckBox->setChecked( false );
		}
		else
		{
			if ( "checked" == tag )
			{
				inCheckBox->setChecked();
			}
			else
				return false; // wanted "value=" or "checked"
		}

		if ( ! parse_until( ">", checkname ) )  //Discard until >
			return false;

		if ( ! parse_until( "</input>", checkname ) )   // grab until </input>
			return false;

		inCheckBox->setText( checkname );
		return true;
	}

	//-------------------------------------------------------------------------

	// html_get( WidgetDataGrid )
	//
	template< class Parent, class MessageMapPolicy >
	bool get( SmartWin::WidgetDataGrid< Parent, MessageMapPolicy > * inWidgetDataGrid )
	{
		string tag;
		itsIo >> tag;
		if ( "<table>" != tag ) return false;

		bool end_table;
		vector< SmartUtil::tstring > colnames, rowvals;
		if ( ! parseRow( colnames, end_table ) ) return false;
		inWidgetDataGrid->createColumns( colnames );

#ifdef __WINE__
		// Avoid Wine crash for setColumnWidth when size is 0,0
		inWidgetDataGrid->setBounds( 0, 0, 40, 40 );
#endif

		for ( unsigned int c = 0; c < colnames.size(); c++ )
		{
			inWidgetDataGrid->setColumnWidth( c, LVSCW_AUTOSIZE_USEHEADER );
		}

		while ( parseRow( rowvals, end_table ) )
		{
			inWidgetDataGrid->insertRow( rowvals );
			rowvals.clear();
		}
		return( end_table );
	}

	//-------------------------------------------------------------------------

	// html_get( WidgetTreeView wtv )
	//
	template< class Parent, class MessageMapPolicy >
	bool get( SmartWin::WidgetTreeView< Parent, MessageMapPolicy > * wtv )
	{
			string tag;
			itsIo >> tag;
			if ( "<ul>" != tag ) return false;

			wtv->DeleteAllItems();

			int dex = 0;
			return html_get_treenode( wtv, TreeViewNode(), dex );
	}

	//-------------------------------------------------------------------------

private:

	//-------------------------------------------------------------------------

	/*
	<html>
	<head>
	<title> </title>
	</head>
	<body>

	<table>
	<tr>
	<TH> Name </TH>
	<TH> Phone </TH>
	</tr>

	<tr>
	<td> Andrew </td>
	<td> 43 </td>
	</tr>

	<tr>
	<td> Fred </td>
	<td> 54 </td>
	</tr>

	</TABLE>
	</body>
	</html>

	*/

	// <tr> <td> data1 </td> <td> data1 </td> </tr>
	//
	bool parseRow( vector< SmartUtil::tstring > & vals, bool & end_table )
	{
			end_table = false;

			string tag, data, token, endtag;
			itsIo >> tag;
			if ( tag != "<tr>" )
			{
				end_table = tag == "</table>";
				return( false );
			}

			while ( true )
			{
				itsIo >> tag;
				if ( ( tag != "<td>" ) && ( tag != "<th>" ) )
				{
					return ( tag == "</tr>" );
				}

				itsIo >> data;
				if ( data == "</td>" )
				{
					data = "";
				}
				else
				{
					itsIo >> endtag;
					while ( ( endtag != "</td>" ) && ( endtag != "</th>" ) )
					{
						data += _T( " " );
						data += endtag;
						itsIo >> endtag;
						if ( 0 == endtag.size() ) return false;
					}
				}
				vals.push_back( data );
			}
	}

	//-------------------------------------------------------------------------

	// Gets <li> data </li>  <ul>  possible nested tree /ul>
	// Put the data into a WidgetTreeView.
	//
	template< class Parent, class MessageMapPolicy >
	bool html_get_treenode( SmartWin::WidgetTreeView< Parent, MessageMapPolicy > * wtv,
			TreeViewNode node, int & dex )
	{
		string tag;
		TreeViewNode childnode;

		do
		{
			itsIo >> tag;

			if ( "<li>" == tag )
			{
				// Parse data in: <li> data </li>
				string data;
				if ( ! parse_until( "</li>", data ) )
				{
					return false;
				}

				// Insert data into node
				childnode = wtv->insertNode( data, node, dex++ );
				continue;
			}

			if ( "<ul>" == tag )
			{
				if ( html_get_treenode( wtv, childnode, dex ) )
				{
					continue;
				}
				else
				{
					return( false );
				}
			}

			if ( "</ul>" == tag )
			{
				break;
			}

			return( false ); // Not ( <li> or <ul> or </ul> )
		} while ( true );

		return true; // Valid data terminated with a </ul>
	}

	//-------------------------------------------------------------------------

	// Parses whitespace seperated text until the endtag occurs.
	// arbitrary whitespace is represented by one space.
	//
	bool parse_until( string endtag, string & data )
	{
		data.clear();
		string moredata;
		while ( true )
		{
			itsIo >> moredata;
			if ( 0 == moredata.size() )
			{
				return false;
			}

			if ( endtag == moredata )
			{
				return true;
			}

			if ( 0 != data.size() )
			{
				data += _T( " " );
			}
			data += moredata;
		}
	}

	//-------------------------------------------------------------------------

	// Extract the number from a string:        value="12"
	//
	bool parse_quoted_numeric_value( string & valstr, int & val )
	{
		string::size_type first_num = valstr.find( '"' );
		if ( first_num == string::npos ) return false;
		first_num++;

		string::size_type last_quote = valstr.find( '"', first_num );
		if ( last_quote == string::npos ) return false;

		string inquotes = valstr.substr( first_num, last_quote - first_num );
		stringstream ss( inquotes );
		ss >> val;
		return true;
	}
};

#endif
