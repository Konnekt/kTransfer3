// $Revision: 1.3 $
/* Copyright (c) 2005 - Thomas Hansen
 * Part of the SmartWin++ library example code
 * Permission to use under the same terms as the actual library
 * The license to the library can be found at http://smartwinlib.org
 * License for library is Open Source and BSD
 */
#ifndef WsdlParser_H
#define WsdlParser_H

#include "SmartSOAP.h"
#include "SmartWin.h"
#include "SmartUtil.h"
#include "SmartXML.h"
#include <boost.h>

using namespace SmartUtil;
using namespace SmartXML;
using namespace SmartHTTP;

// Singleton
class WsdlParser : private boost::noncopyable
{
	// Easy shortcut!
	typedef XmlNode::XmlNodePtr XmlNodePtr;

	WsdlParser()
	{}

public:
	static WsdlParser & instance()
	{
		static WsdlParser tmp;
		return tmp;
	}

	boost::tuples::tuple< SmartUtil::tstring, SmartUtil::tstring > fetchWsdlFromUrl( const tstring & wsdlUrl )
	{
		std::string url = AsciiGuaranteed::doConvert( wsdlUrl, ConversionCodepage::ANSI );
		HttpRequest request( wsdlUrl, _T( "text/xml; charset=utf-8" ), _T( "80" ), 120 );
		HttpRequest::HttpResponsePtr response = request.send( _T( "" ) );
		if ( !response->isGood() )
		{
			tstring tmp;
			std::basic_istream< TCHAR > & stream = response->getContentStream();
			while ( true )
			{
				tstring buffer;
				std::getline( stream, buffer );
				tmp += buffer;
				if ( stream.eof() || !stream.good() )
					break;
			}
			SmartWin::WidgetMessageBoxFree msg;
			msg.show( tmp, _T( "Not good response" ) );
			return boost::tuples::tuple< SmartUtil::tstring, SmartUtil::tstring >();
		}
		std::basic_istream< TCHAR > & stream = response->getContentStream();
		XmlDocument doc( stream );

		boost::tuples::tuple< SmartUtil::tstring, SmartUtil::tstring > retVal( doc.toNormalizedString(), buildProxyClasses( doc ) );
		return retVal;
	}

	// Note that this is just a BASIC WSDL parser, lots of things are "hardcoded" that shouldn't really be hardcoded, but mostly it might work on VC++7.1 and 8.0 WebServices...
	tstring buildProxyClasses( const XmlDocument & doc )
	{
		std::basic_stringstream< TCHAR > proxyClassesStream;
		std::basic_stringstream< TCHAR > proxyClassesCppStream;
		proxyClassesStream << _T( "// Proxy classes autogenerated by SmartSOAPWsdlParser") << _T("\r\n");
		proxyClassesStream << _T( "// This is just an EXAMPLE of a WSDL parser and probably not very stable!!") << _T("\r\n") << _T("\r\n");
		proxyClassesStream << _T( "#include \"SmartSOAP.h\"" ) << _T( "\r\n" );
		proxyClassesStream << _T( "#include \"SmartUtil.h\"" ) << _T( "\r\n" );
		proxyClassesStream << _T( "#include <memory>" ) << _T( "\r\n" ) << _T( "\r\n" );
		tstring nameOfProxyClass;
		std::map< tstring, boost::tuples::tuple< tstring, tstring > > methodNameParamsRetVal;

		const XmlNodePtr docNode = doc.getDocumentNode();

		// First creating the "signal objects" or the objects being passed to and from the WebService methods...!!
		for ( int n = 0; n < 3; ++n )
		{
			for ( XmlNode::const_node_iterator idxElement = ( * docNode )[0][0].children_begin();
				idxElement != ( * docNode )[0][0].children_end();
				++idxElement )
			{
				// Ensuring we get the "complex types" first since the "element types" probably have references to the "complex types"...
				if ( ( n == 0 && ( idxElement->getName() == _T( "complexType" ) || idxElement->getName() == _T( "element" ) ) ) )
				{
					const tstring className = idxElement->findAttribute( _T( "name" ) ) + _T( "Input" );
					proxyClassesStream << _T( "struct " ) << className << _T( ";" ) << _T( "\r\n" );
				}
				else if ( ( n == 1 && idxElement->getName() == _T( "complexType" ) )
					|| ( n == 2 && idxElement->getName() == _T( "element" ) ) )
				{
					const tstring className = idxElement->findAttribute( _T( "name" ) ) + _T( "Input" );
					// Now we have the TYPE declaration for the parameter object of the current method

					proxyClassesStream << _T( "struct " ) << className << _T( "\r\n" ) << "{" << _T( "\r\n" );

					if ( idxElement->children_size() > 0 &&
						( ( n == 2 && ( * idxElement )[0].children_size() > 0 && ( * idxElement )[0][0].children_size() > 0 ) ||
						( * idxElement )[0].children_size() > 0 ) )
					{
						for ( XmlNode::const_node_iterator idxMember = ( n == 2 ? ( * idxElement )[0][0].children_begin() : ( * idxElement )[0].children_begin() );
							idxMember != ( n == 2 ? ( * idxElement )[0][0].children_end() : ( * idxElement )[0].children_end() );
							++idxMember )
						{
							tstring typeNameTmp = idxMember->findAttribute( _T( "type" ) );
							typeNameTmp = typeNameTmp.substr( typeNameTmp.find_first_of( _T( ":" ) ) + 1 );

							tstring typeName;

							if ( typeNameTmp == _T( "int" ) )
							{
								typeName = _T( "int" );
							}
							else if ( typeNameTmp == _T( "string" ) )
							{
								typeName = _T( "SmartUtil::tstring" );
							}
							else if ( typeNameTmp == _T( "dateTime" ) )
							{
								typeName = _T( "SmartUtil::DateTime" );
							}
							else if ( typeNameTmp == _T( "decimal" ) )
							{
								typeName = _T( "double" );
							}
							else if ( typeNameTmp == _T( "float" ) )
							{
								typeName = _T( "float" );
							}
							else if ( typeNameTmp == _T( "double" ) )
							{
								typeName = _T( "double" );
							}
							else
							{
								typeName = typeNameTmp + _T( "Input" ); // Custom class
							}

							tstring variableName = idxMember->findAttribute( _T( "name" ) );

							tstring minOccurs = idxMember->findAttribute( _T( "minOccurs" ) );
							tstring maxOccurs = idxMember->findAttribute( _T( "maxOccurs" ) );
							bool nillable = idxMember->findAttribute( _T( "nillable" ) ) == _T( "true" );

							if ( minOccurs == _T( "1" ) && maxOccurs == _T( "1" ) )
							{
								// Mandatory datamember...
								proxyClassesStream << _T( "\t" ) << typeName << _T( "\t" ) << variableName << _T( ";" ) << _T( "\r\n" );
							}
							else if ( minOccurs == _T( "0" ) && maxOccurs == _T( "1" ) )
							{
								// NOT a Mandatory datamember...
								proxyClassesStream << _T( "\tSmartUtil::null_pointer<" ) << typeName << _T( ">\t" ) << variableName << _T( ";" ) << _T( "\r\n" );
							}
							else if ( minOccurs == _T( "0" ) && maxOccurs == _T( "unbounded" ) )
							{
								// An ARRAY Data member, remember SOME arrays can contain "null values"
								if ( nillable )
									proxyClassesStream << _T( "\tstd::vector<SmartUtil::null_pointer<" ) << typeName << _T( "> >\t" ) << variableName << _T( ";" ) << _T( "\r\n" );
								else
									proxyClassesStream << _T( "\tstd::vector<" ) << typeName << _T( ">\t" ) << variableName << _T( ";" ) << _T( "\r\n" );
							}
						}
					}
					proxyClassesStream << _T( "\r\n" ) << _T( "\tvoid serialize( SmartXML::XmlNode & node ) const;" ) << _T( "\r\n" );
					proxyClassesStream << _T( "\tvoid deserialize( const SmartXML::XmlNode & node );" ) << _T( "\r\n" );

					// Then serializing the "cpp" file, first the "serialize" method
					proxyClassesCppStream << _T( "\r\n" ) << _T( "void " ) << className << _T( "::serialize( SmartXML::XmlNode & node ) const" ) << _T( "\r\n" );
					proxyClassesCppStream << _T( "{" ) << _T( "\r\n" );

					// Doing the actual serialization of the proxy object serializer...
					if ( idxElement->children_size() > 0 &&
						( ( n == 2 && ( * idxElement )[0].children_size() > 0 && ( * idxElement )[0][0].children_size() > 0 ) ||
						( * idxElement )[0].children_size() > 0 ) )
					{
						for ( XmlNode::const_node_iterator idxMember = ( n == 2 ? ( * idxElement )[0][0].children_begin() : ( * idxElement )[0].children_begin() );
							idxMember != ( n == 2 ? ( * idxElement )[0][0].children_end() : ( * idxElement )[0].children_end() );
							++idxMember )
						{
							tstring variableName = idxMember->findAttribute( _T( "name" ) );
							tstring minOccurs = idxMember->findAttribute( _T( "minOccurs" ) );
							tstring maxOccurs = idxMember->findAttribute( _T( "maxOccurs" ) );

							tstring typeNameTmp = idxMember->findAttribute( _T( "type" ) );
							typeNameTmp = typeNameTmp.substr( typeNameTmp.find_first_of( _T( ":" ) ) + 1 );

							bool nativeType = true;
							tstring typeName;
							if ( typeNameTmp == _T( "int" ) )
							{
								typeName = _T( "int" );
							}
							else if ( typeNameTmp == _T( "string" ) )
							{
								typeName = _T( "SmartUtil::tstring" );
							}
							else if ( typeNameTmp == _T( "dateTime" ) )
							{
								typeName = _T( "SmartUtil::DateTime" );
							}
							else if ( typeNameTmp == _T( "decimal" ) )
							{
								typeName = _T( "double" );
							}
							else if ( typeNameTmp == _T( "float" ) )
							{
								typeName = _T( "float" );
							}
							else if ( typeNameTmp == _T( "double" ) )
							{
								typeName = _T( "double" );
							}
							else
							{
								nativeType = false;
								typeName = typeNameTmp + _T( "Input" ); // Custom class
							}

							if ( minOccurs == _T( "1" ) && maxOccurs == _T( "1" ) )
							{
								// Mandatory datamember...
								if ( !nativeType )
								{
									proxyClassesCppStream << _T( "\tSmartXML::XmlNode & " ) << variableName << _T( "Node = node.addChild( _T(\"" + variableName + "\"), _T(\"\"), _T(\"\") );" ) << _T( "\r\n" );
									proxyClassesCppStream << _T( "\t" ) << variableName << _T( ".serialize( " ) << variableName << _T( "Node );" ) << _T( "\r\n" );
								}
								else
								{
									if ( typeName == _T( "SmartUtil::tstring" ) )
										proxyClassesCppStream << _T( "\tnode.addChild( _T(\"" + variableName + "\"), " + variableName + ", _T(\"\") );" ) << _T( "\r\n" );
									else if ( typeName == _T( "SmartUtil::DateTime" ) )
										proxyClassesCppStream << _T( "\tnode.addChild( _T(\"" + variableName + "\"), " + variableName + ".toString(), _T(\"\") );" ) << _T( "\r\n" );
									else
										proxyClassesCppStream << _T( "\tnode.addChild( _T(\"" + variableName + "\"), boost::lexical_cast<SmartUtil::tstring>(" + variableName + "), _T(\"\") );" ) << _T( "\r\n" );
								}
							}
							else if ( minOccurs == _T( "0" ) && maxOccurs == _T( "1" ) )
							{
								// NOT a Mandatory datamember...
								proxyClassesCppStream << _T( "\tif( " ) << variableName << _T( ".get() != 0)" ) << _T( "\r\n" );
								if ( typeName == _T( "SmartUtil::tstring" ) )
									proxyClassesCppStream << _T( "\t\tnode.addChild( _T(\"" + variableName + "\"), *" + variableName + ", _T(\"\") );" ) << _T( "\r\n" );
								else if ( typeName == _T( "SmartUtil::DateTime" ) )
									proxyClassesCppStream << _T( "\t\tnode.addChild( _T(\"" + variableName + "\"), " + variableName + "->toString(), _T(\"\") );" ) << _T( "\r\n" );
								else
								{
									if ( !nativeType )
									{
										proxyClassesCppStream << _T( "\t{" ) << _T( "\r\n" ) << _T( "\t\tSmartXML::XmlNode & " ) << variableName << _T( "Node = node.addChild( _T(\"" + variableName + "\"), _T(\"\"), _T(\"\") );" ) << _T( "\r\n" );
										proxyClassesCppStream << _T( "\t\t" ) << variableName << _T( "->serialize( " ) << variableName << _T( "Node );" ) << _T( "\r\n" );
										proxyClassesCppStream << _T( "\t}" ) << _T( "\r\n" );
									}
									else
										proxyClassesCppStream << _T( "\t\tnode.addChild( _T(\"" + variableName + "\"), boost::lexical_cast<SmartUtil::tstring>(*" + variableName + "), _T(\"\") );" ) << _T( "\r\n" );
								}
							}
							else if ( minOccurs == _T( "0" ) && maxOccurs == _T( "unbounded" ) )
							{
								// An ARRAY Data member
								bool nillable = idxMember->findAttribute( _T( "nillable" ) ) == _T( "true" );

								if ( nillable )
								{
									proxyClassesCppStream << _T( "\tfor( std::vector<SmartUtil::null_pointer<" ) << typeName << _T( "> >::const_iterator idx = " ) << variableName << _T( ".begin();" ) << _T( "\r\n" );
								}
								else
								{
									proxyClassesCppStream << _T( "\tfor( std::vector<" ) << typeName << _T( ">::const_iterator idx = " ) << variableName << _T( ".begin();" ) << _T( "\r\n" );
								}
								proxyClassesCppStream << _T( "\t\t idx != " ) << variableName << _T( ".end();" ) << _T( "\r\n" );
								proxyClassesCppStream << _T( "\t\t ++idx )" ) << _T( "\r\n" );
								proxyClassesCppStream << _T( "\t{" ) << _T( "\r\n" );
								if ( typeName == _T( "SmartUtil::tstring" ) )
								{
									if ( nillable )
										proxyClassesCppStream << _T( "\t\tnode.addChild( _T(\"" + variableName + "\"), **idx, _T(\"\") );" ) << _T( "\r\n" );
									else
										proxyClassesCppStream << _T( "\t\tnode.addChild( _T(\"" + variableName + "\"), *idx, _T(\"\") );" ) << _T( "\r\n" );
								}
								else if ( typeName == _T( "SmartUtil::DateTime" ) )
								{
									if ( nillable )
										proxyClassesCppStream << _T( "\t\tnode.addChild( _T(\"" + variableName + "\"), (*idx)->toString(), _T(\"\") );" ) << _T( "\r\n" );
									else
										proxyClassesCppStream << _T( "\t\tnode.addChild( _T(\"" + variableName + "\"), idx->toString(), _T(\"\") );" ) << _T( "\r\n" );
								}
								else
								{
									if ( !nativeType )
									{
										if ( nillable )
										{
											proxyClassesCppStream << _T( "\t\tSmartXML::XmlNode & " ) << variableName << _T( "Node = node.addChild( _T(\"" + variableName + "\"), _T(\"\"), _T(\"\") );" ) << _T( "\r\n" );
											proxyClassesCppStream << _T( "\t\t(*idx)->serialize( " ) << variableName << _T( "Node );" ) << _T( "\r\n" );
										}
										else
										{
											proxyClassesCppStream << _T( "\t\tSmartXML::XmlNode & " ) << variableName << _T( "Node = node.addChild( _T(\"" + variableName + "\"), _T(\"\"), _T(\"\") );" ) << _T( "\r\n" );
											proxyClassesCppStream << _T( "\t\tidx->serialize( " ) << variableName << _T( "Node );" ) << _T( "\r\n" );
										}
									}
									else
									{
										if ( nillable )
											proxyClassesCppStream << _T( "\t\tnode.addChild( _T(\"" + variableName + "\"), boost::lexical_cast<SmartUtil::tstring>(**idx), _T(\"\") );" ) << _T( "\r\n" );
										else
											proxyClassesCppStream << _T( "\t\tnode.addChild( _T(\"" + variableName + "\"), boost::lexical_cast<SmartUtil::tstring>(*idx), _T(\"\") );" ) << _T( "\r\n" );
									}
								}
								proxyClassesCppStream << _T( "\t}" ) << _T( "\r\n" );
							}
						}
					}

					proxyClassesCppStream << _T( "}" ) << _T( "\r\n" );

					// Then the "deserialize" method
					proxyClassesCppStream << _T( "\r\n" ) << _T( "void " ) << className << _T( "::deserialize( const SmartXML::XmlNode & node )" ) << _T( "\r\n" );
					proxyClassesCppStream << _T( "{" ) << _T( "\r\n" );
					proxyClassesCppStream << _T( "\tint xmlNodeCounter = 0;" ) << _T( "\r\n" ) << _T( "\r\n" );

					if ( idxElement->children_size() > 0 &&
						( ( n == 2 && ( * idxElement )[0].children_size() > 0 && ( * idxElement )[0][0].children_size() > 0 ) ||
						( * idxElement )[0].children_size() > 0 ) )
					{
						// Doing the actual serialization of the proxy object serializer...
						for ( XmlNode::const_node_iterator idxMember = ( n == 2 ? ( * idxElement )[0][0].children_begin() : ( * idxElement )[0].children_begin() );
							idxMember != ( n == 2 ? ( * idxElement )[0][0].children_end() : ( * idxElement )[0].children_end() );
							++idxMember )
						{
							tstring variableName = idxMember->findAttribute( _T( "name" ) );
							tstring minOccurs = idxMember->findAttribute( _T( "minOccurs" ) );
							tstring maxOccurs = idxMember->findAttribute( _T( "maxOccurs" ) );
							bool nillable = idxMember->findAttribute( _T( "nillable" ) ) == _T( "true" );

							tstring typeNameTmp = idxMember->findAttribute( _T( "type" ) );
							typeNameTmp = typeNameTmp.substr( typeNameTmp.find_first_of( _T( ":" ) ) + 1 );

							bool nativeType = true;
							tstring typeName;
							if ( typeNameTmp == _T( "int" ) )
							{
								typeName = _T( "int" );
							}
							else if ( typeNameTmp == _T( "string" ) )
							{
								typeName = _T( "SmartUtil::tstring" );
							}
							else if ( typeNameTmp == _T( "dateTime" ) )
							{
								typeName = _T( "SmartUtil::DateTime" );
							}
							else if ( typeNameTmp == _T( "decimal" ) )
							{
								typeName = _T( "double" );
							}
							else if ( typeNameTmp == _T( "float" ) )
							{
								typeName = _T( "float" );
							}
							else if ( typeNameTmp == _T( "double" ) )
							{
								typeName = _T( "double" );
							}
							else
							{
								nativeType = false;
								typeName = typeNameTmp + _T( "Input" ); // Custom class
							}

							proxyClassesCppStream << _T( "\r\n" );

							if ( minOccurs == _T( "1" ) && maxOccurs == _T( "1" ) )
							{
								// Mandatory datamember...
								if ( !nativeType )
								{
									proxyClassesCppStream << _T( "\t" ) << variableName << _T( ".deserialize( node[xmlNodeCounter++] );" ) << _T( "\r\n" );
								}
								else
								{
									if ( typeName == _T( "SmartUtil::tstring" ) )
										proxyClassesCppStream << _T( "\t" ) << variableName << _T( " = node[xmlNodeCounter++].getContent();" ) << _T( "\r\n" );
									else if ( typeName == _T( "SmartUtil::DateTime" ) )
										proxyClassesCppStream << _T( "\t" ) << variableName << _T( " = SmartUtil::DateTime(node[xmlNodeCounter++].getContent(), _T(\"yyyy.MM.ddThh:mm:ss\"));" ) << _T( "\r\n" );
									else
										proxyClassesCppStream << _T( "\t" ) << variableName << _T( " = boost::lexical_cast<" ) << typeName << _T( ">(node[xmlNodeCounter++].getContent());" ) << _T( "\r\n" );
								}
							}
							else if ( minOccurs == _T( "0" ) && maxOccurs == _T( "1" ) )
							{
								// NOT a Mandatory datamember...
								if ( typeName == _T( "SmartUtil::tstring" ) )
								{
									proxyClassesCppStream << _T( "\tif( node[xmlNodeCounter].getName() == _T(\"" ) << variableName << _T( "\") )" ) << _T( "\r\n" );
									proxyClassesCppStream << _T( "\t\t" ) << variableName << _T( " = new SmartUtil::tstring( node[xmlNodeCounter++].getContent() );" ) << _T( "\r\n" );
								}
								else if ( typeName == _T( "SmartUtil::DateTime" ) )
								{
									proxyClassesCppStream << _T( "\tif( node[xmlNodeCounter].getName() == _T(\"" ) << variableName << _T( "\") )" ) << _T( "\r\n" );
									proxyClassesCppStream << _T( "\t\t" ) << variableName << _T( " = new SmartUtil::DateTime( node[xmlNodeCounter++].getContent(), _T(\"yyyy.MM.ddThh:mm:ss\") );" ) << _T( "\r\n" );
								}
								else
								{
									if ( !nativeType )
									{
										proxyClassesCppStream << _T( "\tif( node[xmlNodeCounter].getName() == _T(\"" ) << variableName << _T( "\") )" ) << _T( "\r\n" );
										proxyClassesCppStream << _T( "\t{" ) << _T( "\r\n" );
										proxyClassesCppStream << _T( "\t\t" ) << variableName << _T( " = new " ) << typeName << _T( ";" ) << _T( "\r\n" );
										proxyClassesCppStream << _T( "\t\t" ) << variableName << _T( "->deserialize( node[xmlNodeCounter++] );" ) << _T( "\r\n" );
										proxyClassesCppStream << _T( "\t}" ) << _T( "\r\n" );
									}
									else
									{
										proxyClassesCppStream << _T( "\tif( node[xmlNodeCounter].getName() == _T(\"" ) << variableName << _T( "\") )" ) << _T( "\r\n" );
										proxyClassesCppStream << _T( "\t\t" ) << variableName << _T( " = new " ) << typeName << _T( "(boost::lexical_cast<" ) << typeName << _T( ">( node[xmlNodeCounter++].getContent() ) );" ) << _T( "\r\n" );
									}
								}
							}
							else if ( minOccurs == _T( "0" ) && maxOccurs == _T( "unbounded" ) )
							{
								// An ARRAY Data member
								proxyClassesCppStream << _T( "\tif( node[xmlNodeCounter].getName() == _T(\"" ) << variableName << _T( "\") )" ) << _T( "\r\n" );
								proxyClassesCppStream << _T( "\t{" ) << _T( "\r\n" );
								proxyClassesCppStream << _T( "\t\tfor( SmartXML::XmlNode::const_node_iterator idx = node.children_begin();" ) << _T( "\r\n" );
								proxyClassesCppStream << _T( "\t\t\t idx != node.children_end();" ) << _T( "\r\n" );
								proxyClassesCppStream << _T( "\t\t\t ++idx )" ) << _T( "\r\n" );
								proxyClassesCppStream << _T( "\t\t{" ) << _T( "\r\n" );
								if ( typeName == _T( "SmartUtil::tstring" ) )
								{
									if ( nillable )
										proxyClassesCppStream << _T( "\t\t\t" ) << variableName << _T( ".push_back( SmartUtil::null_pointer<" ) << typeName << _T( ">( new " ) << typeName << _T( "( idx->getContent() ) ) );" ) << _T( "\r\n" );
									else
										proxyClassesCppStream << _T( "\t\t\t" ) << variableName << _T( ".push_back( idx->getContent() );" ) << _T( "\r\n" );
								}
								else if ( typeName == _T( "SmartUtil::DateTime" ) )
								{
									proxyClassesCppStream << _T( "\t\t\t" ) << variableName << _T( ".push_back( SmartUtil::DateTime( idx->getContent(), _T(\"yyyy.MM.ddThh:mm:ss\") ) );" ) << _T( "\r\n" );
								}
								else
								{
									if ( !nativeType )
									{
										if ( nillable )
										{
											proxyClassesCppStream << _T( "\t\t\tSmartUtil::null_pointer<" ) << typeName << _T( "> tmp;" ) << _T( "\r\n" );
											proxyClassesCppStream << _T( "\t\t\tconst SmartXML::XmlAttribute * attribute = idx->findAttributeComplete( _T( \"nil\" ), _T( \"http : //www.w3.org/2001/XMLSchema-instance\"));") << _T("\r\n");
											proxyClassesCppStream << _T( "\t\t\tif( 0 == attribute || attribute->getContent() != _T(\"true\"))" ) << _T( "\r\n" );
											proxyClassesCppStream << _T( "\t\t\t{" ) << _T( "\r\n" );
											proxyClassesCppStream << _T( "\t\t\t\ttmp = new " ) << typeName << _T( ";" ) << _T( "\r\n" );
											proxyClassesCppStream << _T( "\t\t\t\ttmp->deserialize( *idx );" ) << _T( "\r\n" );
											proxyClassesCppStream << _T( "\t\t\t}" ) << _T( "\r\n" );
											proxyClassesCppStream << _T( "\t\t\t" ) << variableName << _T( ".push_back( tmp );" ) << _T( "\r\n" );
										}
										else
										{
											proxyClassesCppStream << _T( "\t\t\t" ) << typeName << _T( " tmp;" ) << _T( "\r\n" );
											proxyClassesCppStream << _T( "\t\t\ttmp.deserialize( *idx );" ) << _T( "\r\n" );
											proxyClassesCppStream << _T( "\t\t\t" ) << variableName << _T( ".push_back( tmp );" ) << _T( "\r\n" );
										}
									}
									else
										proxyClassesCppStream << _T( "\t\t\t" ) << variableName << _T( ".push_back( boost::lexical_cast<" ) << typeName << _T( ">( idx->getContent() ) );" ) << _T( "\r\n" );
								}
								proxyClassesCppStream << _T( "\t\t}" ) << _T( "\r\n" ) << _T( "\t\t++xmlNodeCounter;" ) << _T( "\r\n" );
								proxyClassesCppStream << _T( "\t}" ) << _T( "\r\n" );
							}
						}
					}

					proxyClassesCppStream << _T( "}" ) << _T( "\r\n" );
					proxyClassesStream << _T( "};" ) << _T( "\r\n" ) << _T( "\r\n" );
				}
			}
			if ( n == 0 )
			{
				proxyClassesStream << _T( "\r\n" );
			}
		}

		tstring location;
		tstring soapAction;

		// Ensuring the header and the SERIALIZERS of the proxy classes comes FIRST!!
		for ( int n = 0; n < 5; ++n )
		{
			// Now creating the actual "proxy class"!!
			for ( XmlNode::const_node_iterator docChildren = docNode->children_begin();
				docChildren != docNode->children_end();
				++docChildren )
			{
				if ( docChildren->getName() == _T( "service" ) && n == 2 )
				{
					// Found the name of the webservice proxy class
					nameOfProxyClass = docChildren->findAttribute( _T( "name" ) );
					proxyClassesStream << _T( "class " ) << nameOfProxyClass << _T( "\r\n" ) << _T( "{" ) << _T( "\r\n" );
				}
				if ( docChildren->getName() == _T( "service" ) && n == 1 )
				{
					// Found the location
					location = ( * docChildren )[0][0].findAttribute( _T( "location" ) );
				}
				else if ( docChildren->getName() == _T( "portType" ) && n == 0 )
				{
					// Here we cache the function names up to their parameter objects and their return type objects...
					for ( XmlNode::const_node_iterator idxOperationParams = docChildren->children_begin();
						idxOperationParams != docChildren->children_end();
						++idxOperationParams )
					{
						boost::tuples::tuple< tstring, tstring > tmpTuple(
							( * idxOperationParams )[0].findAttribute( _T( "message" ) )
							.substr( ( * idxOperationParams )[1].findAttribute( _T( "message" ) ).find_first_of( _T( ':' ) ) + 1 ),
							( * idxOperationParams )[1].findAttribute( _T( "message" ) )
							.substr( ( * idxOperationParams )[1].findAttribute( _T( "message" ) ).find_first_of( _T( ':' ) ) + 1 ) );
						methodNameParamsRetVal[idxOperationParams->findAttribute( _T( "name" ) )] = tmpTuple;
					}
				}
				else if ( docChildren->getName() == _T( "binding" ) && n == 3 )
				{
					// Adding up the serializer classes (in private section, inner classes)
					for ( XmlNode::const_node_iterator idxOperation = docChildren->children_begin();
						idxOperation != docChildren->children_end();
						++idxOperation )
					{
						if ( idxOperation->getName() == _T( "operation" ) )
						{
							// We have found a method
							tstring name = idxOperation->findAttribute( _T( "name" ) );
							soapAction = ( * idxOperation )[0].findAttribute( _T( "soapAction" ) );

							tstring params = boost::tuples::get< 0 >( methodNameParamsRetVal[name] );
							tstring retVal = boost::tuples::get< 1 >( methodNameParamsRetVal[name] );

							tstring nameOfParamsObject;
							tstring nameOfRetValObject;

							for ( XmlNode::const_node_iterator idxMessage = docNode->children_begin();
								idxMessage != docNode->children_end();
								++idxMessage )
							{
								if ( idxMessage->getName() == _T( "message" ) && idxMessage->findAttribute( _T( "name" ) ) == params )
								{
									nameOfParamsObject = ( * idxMessage )[0].findAttribute( _T( "element" ) ).substr( ( * idxMessage )[0].findAttribute( _T( "element" ) ).find_first_of( _T( ':' ) ) + 1 );
									nameOfParamsObject += _T( "Input" );
								}
								else if ( idxMessage->getName() == _T( "message" ) && idxMessage->findAttribute( _T( "name" ) ) == retVal )
								{
									nameOfRetValObject = ( * idxMessage )[0].findAttribute( _T( "element" ) ).substr( ( * idxMessage )[0].findAttribute( _T( "element" ) ).find_first_of( _T( ':' ) ) + 1 );
									nameOfRetValObject += _T( "Input" );
								}
							}

							proxyClassesStream << _T( "\tstruct " ) << name << _T( "Serializer" ) << _T( "\r\n" ) << _T( "\t{" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\tSmartUtil::tstring" ) << _T( " serialize( const " ) << nameOfParamsObject << _T( " & " ) << _T( "input )" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t{" ) << _T( "\r\n" );

							// This is the actual logic of serializing custom object to XML to pass to webservice
							proxyClassesStream << _T( "\t\t\tSmartXML::XmlDocument doc( _T(\"Envelope\"), _T(\"\"), _T(\"soap\") );" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\tSmartXML::XmlNode & rootNode = (*doc.getDocumentNode());" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\trootNode.addNamespace( SmartXML::XmlNamespace( _T( \"http : //www.w3.org/2001/XMLSchema-instance\"), _T(\"xsi\") ) );") << _T("\r\n");
							proxyClassesStream << _T( "\t\t\trootNode.addNamespace( SmartXML::XmlNamespace( _T( \"http : //www.w3.org/2001/XMLSchema\"), _T(\"xsd\") ) );") << _T("\r\n");
							proxyClassesStream << _T( "\t\t\trootNode.addNamespace( SmartXML::XmlNamespace( _T( \"http : //schemas.xmlsoap.org/soap/envelope/\"), _T(\"soap\") ) );") << _T("\r\n");
							proxyClassesStream << _T( "\t\t\tSmartXML::XmlNode & bodyNode = rootNode.addChild( _T(\"Body\"), _T(\"\"), _T(\"soap\") );" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\tSmartXML::XmlNode & functionNameNode = bodyNode.addChild( _T(\"" + name + "\"), _T(\"\"), _T(\"\") );" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\tfunctionNameNode.addNamespace( SmartXML::XmlNamespace( _T(\"" + docNode->findAttribute( _T( "targetNamespace" ) ) + "\") ) );" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\tinput.serialize(functionNameNode);" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\treturn doc.toString();" ) << _T( "\r\n" );

							proxyClassesStream << _T( "\t\t}" ) << _T( "\r\n" ) << _T( "\r\n" );

							proxyClassesStream << _T( "\t\t" ) << nameOfRetValObject << _T( " deserialize( SmartXML::XmlDocument::XmlDocumentPtr document ) const " ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t{" ) << _T( "\r\n" );

							// This is the actual logic of deserializing return value from XML to "custom object"
							proxyClassesStream << _T( "\t\t\t" ) << nameOfRetValObject << _T( " retVal;" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\tretVal.deserialize( (*document->getDocumentNode())[0][0] );" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\treturn retVal;" ) << _T( "\r\n" );

							proxyClassesStream << _T( "\t\t}" ) << _T( "\r\n" );

							proxyClassesStream << _T( "\t};" ) << _T( "\r\n" ) << _T( "\r\n" );
						}
					}
				}
				else if ( docChildren->getName() == _T( "binding" ) && n == 4 )
				{
					// The binding node contains basically the method and its SOAP Action (name of the function when calling it over HTTP)
					proxyClassesStream << _T( "public:" ) << _T( "\r\n" );

					for ( XmlNode::const_node_iterator idxOperation = docChildren->children_begin();
						idxOperation != docChildren->children_end();
						++idxOperation )
					{
						if ( idxOperation->getName() == _T( "operation" ) )
						{
							// We have found a method
							tstring name = idxOperation->findAttribute( _T( "name" ) );
							tstring soapAction = ( * idxOperation )[0].findAttribute( _T( "soapAction" ) );

							tstring params = boost::tuples::get< 0 >( methodNameParamsRetVal[name] );
							tstring retVal = boost::tuples::get< 1 >( methodNameParamsRetVal[name] );

							tstring nameOfParamsObject;
							tstring nameOfRetValObject;

							for ( XmlNode::const_node_iterator idxMessage = docNode->children_begin();
								idxMessage != docNode->children_end();
								++idxMessage )
							{
								if ( idxMessage->getName() == _T( "message" ) && idxMessage->findAttribute( _T( "name" ) ) == params )
								{
									nameOfParamsObject = ( * idxMessage )[0].findAttribute( _T( "element" ) ).substr( ( * idxMessage )[0].findAttribute( _T( "element" ) ).find_first_of( _T( ':' ) ) + 1 );
									nameOfParamsObject += _T( "Input" );
								}
								else if ( idxMessage->getName() == _T( "message" ) && idxMessage->findAttribute( _T( "name" ) ) == retVal )
								{
									nameOfRetValObject = ( * idxMessage )[0].findAttribute( _T( "element" ) ).substr( ( * idxMessage )[0].findAttribute( _T( "element" ) ).find_first_of( _T( ':' ) ) + 1 );
									nameOfRetValObject += _T( "Input" );
								}
							}

							proxyClassesStream << _T( "\r\n" ) << _T( "\t" ) << nameOfRetValObject << _T( "\t" ) << name << _T( "( " ) << nameOfParamsObject << _T( " input" ) << _T( " )" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t{" ) << _T( "\r\n" );

							// Here we instantiate the SoapRequest with our serializer class and so on...
							proxyClassesStream << _T( "\t\t" ) << name << _T( "Serializer serializer;" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\tSmartSOAP::SoapRequest<" ) << name << _T( "Serializer, " ) << nameOfParamsObject << _T( ", " ) << nameOfRetValObject << _T( "> request(" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\t\"" ) << location << _T( "\"," ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\t_T(\"SOAPAction: \\\"" ) << soapAction << _T( "\\\"\")," ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\t80, " ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\tserializer, " ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\tinput " ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\t\t);" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\tSmartSOAP::SoapRequest<" ) << name << _T( "Serializer, " ) << nameOfParamsObject << _T( ", " ) << nameOfRetValObject << _T( ">::SoapResponsePtr response = request.send();" ) << _T( "\r\n" );
							proxyClassesStream << _T( "\t\treturn response->getReturnValue();" ) << _T( "\r\n" );

							proxyClassesStream << _T( "\t}" );
							proxyClassesStream << _T( "\r\n" );
						}
					}
				}
			}
		}

		proxyClassesStream << _T( "};" ) << _T( "\r\n" );

		return proxyClassesStream.str() + proxyClassesCppStream.str();
	}
};

#endif
